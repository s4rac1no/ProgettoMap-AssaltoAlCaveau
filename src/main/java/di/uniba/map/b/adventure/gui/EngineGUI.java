package di.uniba.map.b.adventure.gui;

import di.uniba.map.b.adventure.GameDescription;
import di.uniba.map.b.adventure.Utils;


import static di.uniba.map.b.adventure.Utils.readFile;
import di.uniba.map.b.adventure.database.Database;

import di.uniba.map.b.adventure.games.AssaltoAlCaveau;
import di.uniba.map.b.adventure.parser.Parser;
import di.uniba.map.b.adventure.parser.ParserOutput;
import di.uniba.map.b.adventure.type.AdvObject;
import di.uniba.map.b.adventure.type.Room;
import java.awt.EventQueue;

import java.io.File;
import java.io.IOException;
import java.util.List;

import java.util.Set;

import javax.swing.JOptionPane;
import javax.swing.Timer;

/**
 *
 * @author Leonardo Montemurro, Lorenzo Saracino, Vincenzo Sarra.
 */
public final class EngineGUI extends javax.swing.JFrame {
  /**
   * Attributo d'istanza che identifica il gioco in corso.
   */
  private final GameDescription game;

  /**
   * Attributo d'istanza di inizializzazione parser.
   */
  private Parser parser;


  /**
   * Costruttore di EngineGUI.
   *
   * Questo costruttore crea un'istanza della classe EngineGUI e inizializza il gioco AssaltoAlCaveau.
   * Successivamente, viene chiamato il metodo initializeGui() per inizializzare l'interfaccia grafica.
   */
  public EngineGUI() {
    initComponents();

    this.game = new AssaltoAlCaveau();

    initializeGui();

  }

  /**
   * Inizializzazione dell'interfaccia grafica.
   *
   * Questo metodo gestisce l'inizializzazione dell'interfaccia grafica del gioco.
   * Controlla se è stato caricato un gioco precedente o se è un nuovo gioco e
   * in base a ciò configura l'interfaccia grafica di conseguenza.
   */
  private void initializeGui() {

    if (!GameDescription.loadedGame) {
      this.game.initGame();
      this.game.Intro();
      startButton.setVisible(false);
      fileButton.setEnabled(false);
      inputArea.setVisible(false);
      inventoryButton.setVisible(false);
      roomsDisplay.setVisible(false);
      roomsDisplay.setText("Stanza attuale: " + game.getCurrentRoom().getName());
    } else {
      int roomId = Database.loadPlayerRoom();
      this.game.initGame();
      Room room = EngineGUI.getRoomById(game.getRooms(), roomId);
      if (room != null) {
        game.setCurrentRoom(room);
      }
      Utils timerThread = new Utils(Database.getRemainingTime()); // Imposta il timer con i minuti rimanenti
      timerThread.start();
      fileButton.setEnabled(true);
      time.setVisible(true);
      fileButton.setEnabled(true);
      textPolice.setVisible(true);
      startButton.setVisible(false);
      inputArea.setVisible(true);
      roomsDisplay.setVisible(true);
      inventoryButton.setVisible(true);
      roomsDisplay.setText("Stanza attuale: " + game.getCurrentRoom().getName());
      displayText.setText(game.getCurrentRoom().getDescription()); // Descrizione della stanza attuale
    }
  }

  /**
   * This method is called from within the constructor to initialize the form. WARNING: Do NOT modify this code. The content of this method is always regenerated by the Form Editor.
   */
  @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        portraits = new javax.swing.JLabel();
        display = new javax.swing.JScrollPane();
        displayText = new javax.swing.JTextArea();
        inputArea = new javax.swing.JTextField();
        roomsDisplay = new javax.swing.JTextField();
        startButton = new javax.swing.JButton();
        inventoryButton = new javax.swing.JButton();
        textPolice = new javax.swing.JLabel();
        time = new javax.swing.JLabel();
        restartGameButton = new javax.swing.JButton();
        menuBar = new javax.swing.JMenuBar();
        fileButton = new javax.swing.JMenu();
        saveButton = new javax.swing.JMenuItem();
        helpButton = new javax.swing.JMenu();
        exitButton = new javax.swing.JMenu();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setBackground(new java.awt.Color(0, 0, 0));
        setResizable(false);
        getContentPane().setLayout(new org.netbeans.lib.awtextra.AbsoluteLayout());

        portraits.setVisible(false);
        portraits.setIcon(new javax.swing.ImageIcon("./resources/images/quadri.png"));
        getContentPane().add(portraits, new org.netbeans.lib.awtextra.AbsoluteConstraints(10, 10, 1080, 340));

        display.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_NEVER);
        display.setAutoscrolls(true);
        display.setPreferredSize(new java.awt.Dimension(600, 128));

        displayText.setEditable(false);
        displayText.setBackground(new java.awt.Color(0, 0, 0));
        displayText.setColumns(20);
        displayText.setFont(new java.awt.Font("Monospaced", 0, 16)); // NOI18N
        displayText.setForeground(new java.awt.Color(255, 255, 255));
        displayText.setLineWrap(true);
        displayText.setRows(5);
        displayText.setWrapStyleWord(true);
        displayText.setCaretColor(new java.awt.Color(255, 255, 255));
        displayText.setMargin(new java.awt.Insets(10, 15, 10, 10));
        displayText.setName("displayText"); // NOI18N
        displayText.setPreferredSize(new java.awt.Dimension(595, 125));
        displayText.setSelectedTextColor(new java.awt.Color(0, 0, 0));
        displayText.setSelectionColor(new java.awt.Color(255, 255, 255));
        display.setViewportView(displayText);

        getContentPane().add(display, new org.netbeans.lib.awtextra.AbsoluteConstraints(6, 6, 1085, 345));

        inputArea.setBackground(new java.awt.Color(0, 0, 0));
        inputArea.setFont(new java.awt.Font("Monospaced", 0, 17)); // NOI18N
        inputArea.setForeground(new java.awt.Color(255, 255, 255));
        inputArea.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        inputArea.setCaretColor(new java.awt.Color(255, 255, 255));
        inputArea.setMargin(new java.awt.Insets(5, 5, 5, 5));
        inputArea.setMaximumSize(new java.awt.Dimension(600, 35));
        inputArea.setMinimumSize(new java.awt.Dimension(600, 35));
        inputArea.setName("inputArea"); // NOI18N
        inputArea.setPreferredSize(new java.awt.Dimension(600, 55));
        inputArea.setSelectedTextColor(new java.awt.Color(0, 0, 0));
        inputArea.setSelectionColor(new java.awt.Color(255, 255, 255));
        inputArea.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inputAreaActionPerformed(evt);
            }
        });
        getContentPane().add(inputArea, new org.netbeans.lib.awtextra.AbsoluteConstraints(6, 459, 1299, 63));

        roomsDisplay.setEditable(false);
        roomsDisplay.setBackground(new java.awt.Color(0, 0, 0));
        roomsDisplay.setFont(new java.awt.Font("Monospaced", 0, 17)); // NOI18N
        roomsDisplay.setForeground(new java.awt.Color(255, 255, 255));
        roomsDisplay.setHorizontalAlignment(javax.swing.JTextField.LEFT);
        roomsDisplay.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        roomsDisplay.setCaretColor(new java.awt.Color(255, 255, 255));
        roomsDisplay.setMargin(new java.awt.Insets(5, 5, 5, 5));
        roomsDisplay.setMaximumSize(new java.awt.Dimension(600, 35));
        roomsDisplay.setMinimumSize(new java.awt.Dimension(600, 35));
        roomsDisplay.setName("inputArea"); // NOI18N
        roomsDisplay.setPreferredSize(new java.awt.Dimension(600, 55));
        roomsDisplay.setSelectedTextColor(new java.awt.Color(0, 0, 0));
        roomsDisplay.setSelectionColor(new java.awt.Color(255, 255, 255));
        roomsDisplay.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                roomsDisplayActionPerformed(evt);
            }
        });
        getContentPane().add(roomsDisplay, new org.netbeans.lib.awtextra.AbsoluteConstraints(6, 357, 1299, -1));

        startButton.setFont(new java.awt.Font("Helvetica", 1, 14)); // NOI18N
        startButton.setText("Start");
        startButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                startButtonActionPerformed(evt);
            }
        });
        getContentPane().add(startButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(592, 418, 129, 49));

        inventoryButton.setIcon(new javax.swing.ImageIcon("./resources/images/inventario.jpeg"));
        inventoryButton.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.RAISED));
        inventoryButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                inventoryButtonMouseClicked(evt);
            }
        });
        inventoryButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                inventoryButtonActionPerformed(evt);
            }
        });
        getContentPane().add(inventoryButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(1097, 35, 196, 110));

        textPolice.setVisible(false);
        textPolice.setFont(new java.awt.Font("Noto Sans", 0, 18)); // NOI18N
        textPolice.setText(" Irruzione della polizia tra");
        getContentPane().add(textPolice, new org.netbeans.lib.awtextra.AbsoluteConstraints(1090, 160, 220, -1));

        time.setFont(new java.awt.Font("Noto Sans", 0, 18)); // NOI18N
        getContentPane().add(time, new org.netbeans.lib.awtextra.AbsoluteConstraints(1100, 190, 210, 30));

        restartGameButton.setText("Ricomincia");
        restartGameButton.setVisible(false);
        restartGameButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                restartGameButtonActionPerformed(evt);
            }
        });
        getContentPane().add(restartGameButton, new org.netbeans.lib.awtextra.AbsoluteConstraints(1110, 250, 170, 40));

        fileButton.setEnabled(false);
        fileButton.setText("File");

        saveButton.setText("salva");
        saveButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                saveButtonActionPerformed(evt);
            }
        });
        fileButton.add(saveButton);

        menuBar.add(fileButton);

        helpButton.setText("Comandi");
        helpButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                helpButtonMouseClicked(evt);
            }
        });
        helpButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                helpButtonActionPerformed(evt);
            }
        });
        menuBar.add(helpButton);

        exitButton.setText("Esci");
        exitButton.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                exitButtonMouseClicked(evt);
            }
        });
        exitButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                exitButtonActionPerformed(evt);
            }
        });
        menuBar.add(exitButton);

        setJMenuBar(menuBar);

        pack();
        setLocationRelativeTo(null);
    }// </editor-fold>//GEN-END:initComponents

  /**
   * Azione dell'area di input.
   *
   * Questo metodo gestisce l'azione scatenata dall'area di input quando viene premuto il tasto "Invio".
   * Prende il testo inserito nell'area di input, lo processa utilizzando il parser e il gioco corrente,
   * quindi esegue la mossa successiva del gioco in base al comando analizzato.
   */
  private void inputAreaActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inputAreaActionPerformed


    inputArea.setText("");

    String command = evt.getActionCommand();



    try {

      Set<String> stopwords = Utils.loadFileListInSet(new File("./resources/txt/stopwords"));
      parser = new Parser(stopwords);

      ParserOutput p = parser.parse(command, game.getCommands(), game.getCurrentRoom().getObjects(), game.getInventory());


      if (p.getCommand() != null) { // Se ho trovato il comando

        game.nextMove(p);

        inputArea.setEditable(false);

      } else { // Se non ho digitato niente

        displayText.setText("Così non capisco! :|");

      }

    } catch (IOException ex) {
      System.err.println(ex + "Errore!");
    }
  }//GEN-LAST:event_inputAreaActionPerformed

  private void roomsDisplayActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_roomsDisplayActionPerformed

  }//GEN-LAST:event_roomsDisplayActionPerformed

  /**
   * Azione del pulsante di avvio.
   * Questo metodo gestisce l'azione scatenata dal pulsante di avvio quando viene premuto.
   * Imposta il timer del gioco, abilita i pulsanti e gli elementi dell'interfaccia grafica,
   * quindi mostra la descrizione della stanza attuale.
   */
  private void startButtonActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_startButtonActionPerformed

    Utils timerThread = new Utils(20 * 60); // Imposta il timer in minuti
    timerThread.start();
    fileButton.setEnabled(true);
    time.setVisible(true);
    textPolice.setVisible(true);
    startButton.setVisible(false);
    inputArea.setVisible(true);
    roomsDisplay.setVisible(true);
    inventoryButton.setVisible(true);
    displayText.setText(game.getCurrentRoom().getDescription()); // Descrizione della stanza attuale
  }//GEN-LAST:event_startButtonActionPerformed


  private void helpButtonActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_helpButtonActionPerformed

  }//GEN-LAST:event_helpButtonActionPerformed

  /**
   * Azione del click del pulsante di aiuto.
   *
   * Questo metodo gestisce l'azione scatenata dal click del pulsante di aiuto.
   * Riproduce un effetto sonoro, carica il testo di aiuto da un file e mostra un messaggio di dialogo
   * con il testo di aiuto come contenuto.
   */
  private void helpButtonMouseClicked(final java.awt.event.MouseEvent evt) {//GEN-FIRST:event_helpButtonMouseClicked
    Music.playEffect("./resources/soundEffects/button.wav");
    String help = readFile("./resources/txt/Help.txt");
    JOptionPane.showMessageDialog(this, help, "Lista Comandi", JOptionPane.INFORMATION_MESSAGE);
  }//GEN-LAST:event_helpButtonMouseClicked


  private void inventoryButtonActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_inventoryButtonActionPerformed
    // TODO add your handling code here:
  }//GEN-LAST:event_inventoryButtonActionPerformed

  /**
   * Azione del click del pulsante dell'inventario.
   *
   * Questo metodo gestisce l'azione scatenata dal click del pulsante dell'inventario.
   * Riproduce un effetto sonoro, costruisce una stringa contenente gli oggetti presenti nell'inventario non ancora utilizzati
   * e mostra un messaggio di dialogo con la lista degli oggetti dell'inventario come contenuto.
   */
  private void inventoryButtonMouseClicked(final java.awt.event.MouseEvent evt) {//GEN-FIRST:event_inventoryButtonMouseClicked

    Music.playEffect("./resources/soundEffects/button.wav");
    StringBuilder inventoryBuilder = new StringBuilder(); // StringBuilder per costruire la stringa dell'inventario

    int i = 0; // Numero di oggetti nell'inventario non ancora utilizzati

    for (AdvObject advObject : game.getInventory()) { // Itera oggetti nell'inventario
      if (!advObject.isUsed()) { // Se l'oggetto non è stato utilizzato

        inventoryBuilder.append("- ").append(advObject.getName()).append("\n"); // Aggiungi il nome dell'oggetto all'inventario
        i++;
      }

    }
    inventoryBuilder.append("\nPer avere più informazioni digita: esamina <oggetto>");

    String inventory = inventoryBuilder.toString(); // Converti il contenuto del StringBuilder in una stringa
    JOptionPane.showMessageDialog(this, inventory, "Inventario", JOptionPane.INFORMATION_MESSAGE);

  }//GEN-LAST:event_inventoryButtonMouseClicked

  private void exitButtonActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_exitButtonActionPerformed

  }//GEN-LAST:event_exitButtonActionPerformed

  /**
   * Azione del click del pulsante di uscita.
   * Questo metodo gestisce l'azione scatenata dal click del pulsante di uscita.
   * Riproduce un effetto sonoro e termina l'applicazione chiudendo il programma.
   */
  private void exitButtonMouseClicked(final java.awt.event.MouseEvent evt) {//GEN-FIRST:event_exitButtonMouseClicked
    Music.playEffect("./resources/soundEffects/button.wav");
    System.exit(0);
  }//GEN-LAST:event_exitButtonMouseClicked

  /**
   * Azione del click del pulsante di riavvio del gioco.
   *
   * Questo metodo gestisce l'azione scatenata dal click del pulsante di riavvio del gioco.
   * Interrompe la riproduzione della musica di sottofondo, chiude la finestra corrente e apre una nuova finestra del menu principale.
   */
  private void restartGameButtonActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_restartGameButtonActionPerformed
    Music.stopMusic();
    closeWindow();
    new MenuGui().setVisible(true);
  }//GEN-LAST:event_restartGameButtonActionPerformed

  /**
   * Azione del click del pulsante di salvataggio.
   *
   * Questo metodo gestisce l'azione scatenata dal click del pulsante di salvataggio.
   * Riproduce un effetto sonoro di pulsante, elimina i dati del giocatore dal database,
   * salva l'ID e il nome della stanza corrente insieme al tempo rimanente nel database,
   * e visualizza un messaggio di conferma o di errore a seconda dell'esito del salvataggio.
   *
   * @param evt L'evento di azione generato dal click del pulsante.
   */
  private void saveButtonActionPerformed(final java.awt.event.ActionEvent evt) {//GEN-FIRST:event_saveButtonActionPerformed
    Music.playEffect("./resources/soundEffects/button.wav");
    try {
      Database.deletePlayerData();
      Database.savePlayerRoom(game.getCurrentRoom().getId(), game.getCurrentRoom().getName(), Utils.getRemainingTime());
      displayTextSetDelay("Salvataggio eseguito!");
    } catch (Exception ex) {
      displayTextSetDelay("Si è verificato un errore con il salvataggio!");
    }
  }//GEN-LAST:event_saveButtonActionPerformed

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private static javax.swing.JScrollPane display;
    private static javax.swing.JTextArea displayText;
    private static javax.swing.JMenu exitButton;
    private static javax.swing.JMenu fileButton;
    private static javax.swing.JMenu helpButton;
    private static javax.swing.JTextField inputArea;
    private static javax.swing.JButton inventoryButton;
    private static javax.swing.JMenuBar menuBar;
    private static javax.swing.JLabel portraits;
    private static javax.swing.JButton restartGameButton;
    private static javax.swing.JTextField roomsDisplay;
    private static javax.swing.JMenuItem saveButton;
    private static javax.swing.JButton startButton;
    private static javax.swing.JLabel textPolice;
    private static javax.swing.JLabel time;
    // End of variables declaration//GEN-END:variables



  /**
   * Stampa i messaggi in output in maniera ritardata, lettera per lettera,
   * grazie all'utilizzo del timer.
   *
   *
   * @param s La String da aggiungere al testo presente nella variabile 'displayText'
   */
  public static void displayTextSetDelay(final String s) {

    int delay = 10; // Ritardo di 100 millisecondi tra le lettere
    final int[] index = {0}; //array di interi dimensione 1 che mantiene il valore dell'indice
    // perchè all'interno della lambda expression la variabile
    //index non può essere modificata perchè deve essere final (finale)

    Timer timer = new Timer(delay, e -> {
      if (index[0] < s.length()) {
        String partialText = s.substring(0, index[0] + 1);
        displayText.setText(partialText);
        index[0]++;
      } else {
        ((Timer) e.getSource()).stop(); // Ferma il timer quando tutte le lettere sono state visualizzate
        inputArea.setEditable(true);
        inputArea.setCaretPosition(0); // Imposta il cursore all'inizio del testo
        inputArea.requestFocusInWindow(); // Imposta il focus sull'area di input
      }

    });

    timer.start();
  }

  /**
   *
   * Stampa l'intro lettera per lettra in maniera ritardata, grazie all'utilizzo del timer
   * il ritardo è di 100 millisecondi.
   * Inoltre viene riprodotto un effetto sonoro.
   *
   * @param s La String da sostituire al testo presente nella variabile 'displayText'
   */
  public static void displayIntroTextSet(final String s) {

    Music.playEffect("./resources/soundEffects/keyboardsound.wav"); //riproduci suono tastiera
    int delay = 10; // Ritardo di 100 millisecondi tra le lettere
    final int[] index = {0}; //array di interi dimensione 1 che mantiene il valore dell'indice
    // perchè all'interno della lambda expression la variabile
    //index non può essere modificata perchè deve essere final (finale)

    Timer timer = new Timer(delay, e -> {
      if (index[0] < s.length()) {
        String partialText = s.substring(0, index[0] + 1);
        displayText.setText(partialText);
        index[0]++;
      } else {
        ((Timer) e.getSource()).stop(); // Ferma il timer quando tutte le lettere sono state visualizzate
        startButton.setVisible(true);  //rendo visibile il bottone 'start' quando il testo viene stampato
        inputArea.setCaretPosition(0); // Imposta il cursore all'inizio del testo
        inputArea.requestFocusInWindow(); // Imposta il focus sull'area di input
      }

    });

    timer.start();

  }

  /**
   * Visualizza il testo gradualmente con un ritardo tra le lettere.
   *
   * Questo metodo visualizza gradualmente il testo specificato nell'area di visualizzazione
   * con un ritardo tra le lettere. Viene utilizzato un timer per gestire il ritardo tra
   * l'apparizione di ogni lettera. Una volta che tutte le lettere sono state visualizzate,
   * l'area di input viene abilitata, il cursore viene posizionato all'inizio del testo
   * e l'area di input ottiene il focus.
   *
   * @param s Il testo da visualizzare gradualmente.
   */
  public static void displayTextSetDelayOpen(final String s) {

    int delay = 30; // Ritardo di 100 millisecondi tra le lettere
    final int[] index = {0}; //array di interi dimensione 1 che mantiene il valore dell'indice
    // perchè all'interno della lambda expression la variabile
    //index non può essere modificata perchè deve essere final (finale)

    Timer timer = new Timer(delay, e -> {
      if (index[0] < s.length()) {
        String partialText = s.substring(0, index[0] + 1);
        displayText.setText(partialText);
        index[0]++;
      } else {
        ((Timer) e.getSource()).stop(); // Ferma il timer quando tutte le lettere sono state visualizzate
        inputArea.setEditable(true);
        inputArea.setCaretPosition(0); // Imposta il cursore all'inizio del testo
        inputArea.requestFocusInWindow(); // Imposta il focus sull'area di input
      }
    });

    timer.start();
  }

  /**
   * Metodo gestione del delay per la stampa di uno dei due finali presenti nel gioco.
   * @param s stampa vittoria o gameover.
   */
  public static void displayTextSetDelayEnd(final String s) {

    int delay = 30; // Ritardo di 100 millisecondi tra le lettere
    final int[] index = {0}; //array di interi dimensione 1 che mantiene il valore dell'indice
    // perchè all'interno della lambda expression la variabile
    //index non può essere modificata perchè deve essere final (finale)

    Timer timer = new Timer(delay, e -> {
      if (index[0] < s.length()) {
        String partialText = s.substring(0, index[0] + 1);
        displayText.setText(partialText);
        index[0]++;
      } else {
        ((Timer) e.getSource()).stop(); // Ferma il timer quando tutte le lettere sono state visualizzate
        inputArea.setEditable(false);
        showRestartGameButton();
      
        
      }
    });
    timer.start();
  }

  /**
   * Questo metodo aggiunge il valore di 's' al testo della variabile 'displayText'.
   *
   * @param s La String da aggiungere al testo presente nella variabile 'displayText'
   */
  public static void displayTextSetNormal(String s) {

    displayText.setText(s);
    inputArea.setEditable(true);
    inputArea.setCaretPosition(0); // Imposta il cursore all'inizio del testo
    inputArea.requestFocusInWindow(); // Imposta il focus sull'area di input
  }

  /**
   * Questo metodo aggiunge il valore di 's' al testo della variabile 'displayText'.
   *
   * @param s La String da aggiungere al testo presente nella variabile 'displayText'
   */
  public static void displayTextAppend(String s) {

    displayText.append(s);
    inputArea.setEditable(true);
    inputArea.setCaretPosition(0); // Imposta il cursore all'inizio del testo
    inputArea.requestFocusInWindow(); // Imposta il focus sull'area di input
  }

  /**
   * Mostra i ritratti dei personaggi.
   *
   * Questo metodo imposta la visibilità del pannello dei ritratti su true e la visibilità
   * dell'area di visualizzazione su false. Di conseguenza, vengono mostrati i ritratti,
   * mentre il display viene nascosto.
   */
  public static void showPortraits() {
    portraits.setVisible(true);
    display.setVisible(false);
  }
  /**
   * Nasconde i ritratti dei personaggi.
   *
   * Questo metodo imposta la visibilità del pannello dei ritratti su false e la visibilità
   * dell'area di visualizzazione su true. Di conseguenza, i ritratti vengono
   * nascosti e viene mostrata nuovamente il display.
   */
  public static void hidePortraits() {
    portraits.setVisible(false);
    display.setVisible(true);
  }

  /**
   * Metodo per verificare se i quadri sono visibili.
   * @return true se i quadri sono visibili, false altrimenti.
   */
  public static boolean isPortraitsVisible() {
    if(portraits.isVisible()) {
      return true;
    }
    return false;
  }

  /**
   * Mostra il tempo rimanente nel gioco.
   *
   * Questo metodo visualizza il tempo rimanente nel gioco in base al testo fornito come input.
   * Il testo rappresenta il numero di secondi rimanenti. Il metodo calcola il numero di minuti
   * e i secondi rimanenti a partire dal testo fornito e imposta il testo corrispondente nel
   * componente "time" dell'interfaccia grafica.
   *
   * @param text il testo rappresentante il numero di secondi rimanenti
   */
  public static void displayTime(String text) {
    EventQueue.invokeLater(() -> {

      int i = Integer.parseInt(text);
      int minutes = i / 60;
      int remainingSeconds = i % 60;
      if (minutes > 0 && minutes != 1) {
        time.setText(minutes + " minuti e " + remainingSeconds + " secondi");
      } else if (minutes == 1) {
        time.setText(minutes + " minuto e " + remainingSeconds + " secondi");
      } else {
        time.setText("           " + remainingSeconds + " secondi");
      }
    });
  }

  /**
   * Metodo per disabilitare la inputArea
   * nel caso in cui il giocatore non deve
   * poter inserire dati in input.
   */
  public static void disableInputArea() {
    inputArea.setText("");
    inputArea.setEditable(false);
  }

  /**
   * Nasconde le etichette dell'interfaccia grafica.
   * Questo metodo nasconde le varie labels dell'interfaccia grafica, inclusi i ritratti e il tempo.
   * Se i ritratti sono visibili, viene chiamatoil metodo `hidePortraits()` per nasconderli.
   * Infine, viene 'ripulito' il display.
   */
  public static void hideLabels() {
    if (portraits.isVisible()) {
      hidePortraits();
    }
    time.setVisible(false);
    textPolice.setVisible(false);
    roomsDisplay.setText("");
  }

  /**
   * Metodo d'istanza che permette il ritorno al
   * menù quando il tempo a disposizione termina.
   * @param text
   */
  public static void returnToMenu(String text) {
    inputArea.setText("Ritornerai al menù iniziale tra " + text + " secondi...");
  }

  /**
   * Metodo d'istanza per impostare il numero di secondi
   * necessari al ritorno al menù principale nel caso
   * in cui il tempo a disposizione termini.
   *
   */
  public static void restartTimer() {
    Utils timerThread = new Utils(10); // Imposta il timer in minuti
    timerThread.start();
  }

  /**
   * Metodo per la visualizzazione del pulsante di restart.
   */
  public static void showRestartGameButton() {
    restartGameButton.setVisible(true);
  }

  /**
   * Metodo che consente la chiusura delle schede di EngineGUi.
   */
  public static void closeWindow() {
    java.awt.Window[] windows = java.awt.Window.getWindows(); //Ottiene tutte le finestre aperte nell'applicazione
    for (java.awt.Window window : windows) { //itera attraverso tutte le finestre
      if (window instanceof EngineGUI) { //controlla se la finestra è un'istanza della classe EngineGUI
        window.dispose(); //Chiude la finestra chiamando il metodo dispose()
      }
    }
  }

  /**
   * Questo metodo aggiunge il valore di 's' al testo della variabile 'roomsDisplay'.
   *
   * @param s La String da aggiungere al testo presente nella variabile 'roomsDisplay'
   */
  public static void roomsDisplayTextSet(final String s) {
    roomsDisplay.setText(s);
  }

  /**
   * Questo metodo ricerca l'id presente nel database in tutte le
   * stanze presenti nel gioco, se trova
   * una corrispondenza di id con un oggetto d'istanza di Room,
   * ritorna l'id dell'oggetto dell'istanza. Null altrimenti.
   * @param rooms Insieme delle stanze presenti nel gioco
   * @param roomId Id presente nel database.
   * @return Id della stanza se c'è corrispondenza, false altrimenti.
   */
  public static Room getRoomById(final List<Room> rooms, final int roomId) {
    for (Room room : rooms) {
      if (room.getId() == roomId) {
        return room; // Restituisce l'oggetto Room corrispondente all'ID
      }
    }
    return null; // Se non viene trovato alcun oggetto Room con l'ID specificato
  }
  
  /**
   * Metodo per disattivare saveButton quando ci troviamo nel GameOver/win.
   */
  public static void hideFileEnd() {
   fileButton.setEnabled(false);
  }
}
